name: Build, Push, and Deploy E-Shop (v5 - File-based)

on:
  push:
    branches: [ master ]

env:
  REGISTRY: ghcr.io
  IMAGE_OWNER: ${{ github.repository_owner }}

jobs:
  # Job 1: Build the base image ONLY if base files changed
  build-base:
    name: Build Base Image
    runs-on: ubuntu-latest
    outputs:
      built: ${{ steps.build-step.outputs.built }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for base file changes
        id: check-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            Dockerfile.base
            package.json
            package-lock.json
            prisma/schema.prisma
            nx.json
            tsconfig.base.json
          base_sha: ${{ github.event.before }}

      - name: Log in to GHCR
        if: steps.check-files.outputs.any_changed == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Set up Docker Buildx
        if: steps.check-files.outputs.any_changed == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build and push eshop-base
        id: build-step
        if: steps.check-files.outputs.any_changed == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.base
          push: true
          no-cache: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/eshop-base:latest
          secrets: |
            GIT_AUTH_TOKEN=${{ secrets.GHCR_PAT }}
      
      # This output tells other jobs if the base was rebuilt
      - name: Set output
        if: ${{ always() }} # Ensures this step runs even if build is skipped
        run: echo "built=${{ steps.build-step.outcome == 'success' }}" >> $GITHUB_OUTPUT

  # --- Jobs for each service ---
  # We check for:
  # 1. Changes in the app's own folder
  # 2. Changes in any shared 'packages' folder
  # 3. If the base image itself was rebuilt
  # 4. Changes to the app's specific Dockerfile
  # If ANY are true, we build.

  build-user-ui:
    name: Build (user-ui)
    needs: [build-base]
    runs-on: ubuntu-latest
    outputs:
      built: ${{ steps.build-step.outputs.built }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - name: Check for app/shared file changes
        id: check-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            apps/user-ui/**/*
            packages/**/*
            Dockerfile.frontend
          base_sha: ${{ github.event.before }}
      - name: Set 'run-build' flag
        id: set-flag
        run: |
          if [ "${{ steps.check-files.outputs.any_changed }}" == "true" ] || [ "${{ needs.build-base.outputs.built }}" == "true" ]; then
            echo "run_build=true" >> $GITHUB_OUTPUT
          else
            echo "run_build=false" >> $GITHUB_OUTPUT
          fi
      - name: Log in to GHCR
        if: steps.set-flag.outputs.run_build == 'true'
        uses: docker/login-action@v3
        with: { registry: ${{ env.REGISTRY }}, username: ${{ github.actor }}, password: ${{ secrets.GHCR_PAT }} }
      - name: Set up Docker Buildx
        if: steps.set-flag.outputs.run_build == 'true'
        uses: docker/setup-buildx-action@v3
      - name: Build and push user-ui
        id: build-step
        if: steps.set-flag.outputs.run_build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          build-args: |
            APP_NAME=user-ui
            NEXT_PUBLIC_SERVER_URI=${{ vars.NEXT_PUBLIC_SERVER_URI }}
            NEXT_PUBLIC_CHATTING_WEBSOCKET_URI=${{ vars.NEXT_PUBLIC_CHATTING_WEBSOCKET_URI }}
            NEXT_PUBLIC_STRIPE_PUBLIC_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLIC_KEY }}
            NEXT_PUBLIC_USER_URI=${{ vars.NEXT_PUBLIC_USER_URI }}
            NEXT_PUBLIC_SELLER_URI=${{ vars.NEXT_PUBLIC_SELLER_URI }}
          push: true
          no-cache: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/eshop-user-ui:latest
          secrets: |
            GIT_AUTH_TOKEN=${{ secrets.GHCR_PAT }}
      - name: Set output
        if: ${{ always() }}
        run: echo "built=${{ steps.build-step.outcome == 'success' }}" >> $GITHUB_OUTPUT

  build-seller-ui:
    name: Build (seller-ui)
    needs: [build-base]
    runs-on: ubuntu-latest
    outputs:
      built: ${{ steps.build-step.outputs.built }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - name: Check for app/shared file changes
        id: check-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            apps/seller-ui/**/*
            packages/**/*
            Dockerfile.frontend
          base_sha: ${{ github.event.before }}
      - name: Set 'run-build' flag
        id: set-flag
        run: |
          if [ "${{ steps.check-files.outputs.any_changed }}" == "true" ] || [ "${{ needs.build-base.outputs.built }}" == "true" ]; then
            echo "run_build=true" >> $GITHUB_OUTPUT
          else
            echo "run_build=false" >> $GITHUB_OUTPUT
          fi
      - name: Log in to GHCR
        if: steps.set-flag.outputs.run_build == 'true'
        uses: docker/login-action@v3
        with: { registry: ${{ env.REGISTRY }}, username: ${{ github.actor }}, password: ${{ secrets.GHCR_PAT }} }
      - name: Set up Docker Buildx
        if: steps.set-flag.outputs.run_build == 'true'
        uses: docker/setup-buildx-action@v3
      - name: Build and push seller-ui
        id: build-step
        if: steps.set-flag.outputs.run_build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          build-args: |
            APP_NAME=seller-ui
            NEXT_PUBLIC_SERVER_URI=${{ vars.NEXT_PUBLIC_SERVER_URI }}
            NEXT_PUBLIC_CHATTING_WEBSOCKET_URI=${{ vars.NEXT_PUBLIC_CHATTING_WEBSOCKET_URI }}
            NEXT_PUBLIC_STRIPE_PUBLIC_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLIC_KEY }}
            NEXT_PUBLIC_USER_URI=${{ vars.NEXT_PUBLIC_USER_URI }}
            NEXT_PUBLIC_SELLER_URI=${{ vars.NEXT_PUBLIC_SELLER_URI }}
          push: true
          no-cache: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/eshop-seller-ui:latest
          secrets: |
            GIT_AUTH_TOKEN=${{ secrets.GHCR_PAT }}
      - name: Set output
        if: ${{ always() }}
        run: echo "built=${{ steps.build-step.outcome == 'success' }}" >> $GITHUB_OUTPUT

  # Generic job for all backend services
  build-backends:
    name: Build Backend (${{ matrix.app }})
    needs: [build-base]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: [api-gateway, auth-service, product-service, order-service, chatting-service, kafka-service]
    outputs:
      built: ${{ steps.build-step.outputs.built }}
      app_name: ${{ matrix.app }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - name: Check for app/shared file changes
        id: check-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            apps/${{ matrix.app }}/**/*
            packages/**/*
            Dockerfile.backend
          base_sha: ${{ github.event.before }}
      - name: Set 'run-build' flag
        id: set-flag
        run: |
          if [ "${{ steps.check-files.outputs.any_changed }}" == "true" ] || [ "${{ needs.build-base.outputs.built }}" == "true" ]; then
            echo "run_build=true" >> $GITHUB_OUTPUT
          else
            echo "run_build=false" >> $GITHUB_OUTPUT
          fi
      - name: Log in to GHCR
        if: steps.set-flag.outputs.run_build == 'true'
        uses: docker/login-action@v3
        with: { registry: ${{ env.REGISTRY }}, username: ${{ github.actor }}, password: ${{ secrets.GHCR_PAT }} }
      - name: Set up Docker Buildx
        if: steps.set-flag.outputs.run_build == 'true'
        uses: docker/setup-buildx-action@v3
      - name: Build and push backend (${{ matrix.app }})
        id: build-step
        if: steps.set-flag.outputs.run_build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.backend
          build-args: |
            APP_NAME=${{ matrix.app }}
          push: true
          no-cache: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/eshop-${{ matrix.app }}:latest
          secrets: |
            GIT_AUTH_TOKEN=${{ secrets.GHCR_PAT }}
      - name: Set output
        if: ${{ always() }}
        run: echo "built=${{ steps.build-step.outcome == 'success' }}" >> $GITHUB_OUTPUT

  # Final job: Gathers all 'built' outputs and deploys ONLY the ones that changed
  deploy:
    name: Deploy Affected Services
    needs:
      - build-user-ui
      - build-seller-ui
      - build-backends
    runs-on: ubuntu-latest
    # We use if: always() so this job runs even if some builds were skipped (built=false)
    # This allows us to collect all results
    if: always()

    steps:
      - name: Build list of affected services
        id: build-list
        run: |
          AFFECTED_SERVICES=""
          
          if [ "${{ needs.build-user-ui.outputs.built }}" == "true" ]; then
            AFFECTED_SERVICES="$AFFECTED_SERVICES user-ui"
          fi
          if [ "${{ needs.build-seller-ui.outputs.built }}" == "true" ]; then
            AFFECTED_SERVICES="$AFFECTED_SERVICES seller-ui"
          fi
          
          # This part reads the matrix job outputs
          # We need to check each one individually
          # Note: This assumes you know the matrix names. 
          # A cleaner way is to use JSON, but this is more explicit.
          
          ${{ contains(fromJson('["api-gateway", "auth-service", "product-service", "order-service", "chatting-service", "kafka-service"]'), needs.build-backends.outputs.app_name) && needs.build-backends.outputs.built == 'true' }}
          
          # --- A more robust way to handle matrix ---
          # We check the 'outputs' object from the matrix job
          # This is complex, so we'll just check all possible matrix apps
          
          backend_outputs='${{ toJSON(needs.build-backends.outputs) }}'
          
          # This is a bit of a hack to check all matrix outputs
          # A better way would be to have separate jobs, but let's try this.
          # We'll just manually check each app name based on the matrix.
          
          if [ "${{ needs.build-backends.outputs.built-api-gateway }}" == "true" ]; then AFFECTED_SERVICES="$AFFECTED_SERVICES api-gateway"; fi
          if [ "${{ needs.build-backends.outputs.built-auth-service }}" == "true" ]; then AFFECTED_SERVICES="$AFFECTED_SERVICES auth-service"; fi
          if [ "${{ needs.build-backends.outputs.built-product-service }}" == "true" ]; then AFFECTED_SERVICES="$AFFECTED_SERVICES product-service"; fi
          if [ "${{ needs.build-backends.outputs.built-order-service }}" == "true" ]; then AFFECTED_SERVICES="$AFFECTED_SERVICES order-service"; fi
          if [ "${{ needs.build-backends.outputs.built-chatting-service }}" == "true" ]; then AFFECTED_SERVICES="$AFFECTED_SERVICES chatting-service"; fi
          if [ "${{ needs.build-backends.outputs.built-kafka-service }}" == "true" ]; then AFFECTED_SERVICES="$AFFECTED_SERVICES kafka-service"; fi

          # --- This logic is getting too complex for 'run'. Let's simplify. ---
          # We will abandon the matrix for 'build-backends' and make them all separate jobs.
          # This is the ONLY way to make the 'deploy' job reliable.
          echo "THIS WORKFLOW (v5) IS INCORRECT. PLEASE USE v6."
          exit 1