name: Build, Push, and Deploy E-Shop (Optimized v2)

on:
  push:
    branches: [ master ]

env:
  REGISTRY: ghcr.io
  IMAGE_OWNER: ${{ github.repository_owner }}

jobs:
  # Job 1: Determine which apps are affected by the code changes
  determine-affected:
    name: Determine Affected Apps
    runs-on: ubuntu-latest
    outputs:
      affected_apps_json: ${{ steps.get-affected.outputs.affected_apps_json }}
      affected_apps_list: ${{ steps.get-affected.outputs.affected_apps_list }}
      build_base: ${{ steps.get-affected.outputs.build_base }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # We need the full history (or at least 2 commits) to compare
          fetch-depth: 0 

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Match your Dockerfiles
          cache: 'npm'

      - name: Install dependencies (matching Dockerfile.base)
        run: npm install --legacy-peer-deps # <-- FIX 1: Match your Dockerfile.base

      - name: Check for base file changes
        id: check-base
        uses: tj-actions/changed-files@v44
        with:
          files: |
            package.json
            package-lock.json
            Dockerfile.base
            nx.json
            tsconfig.base.json
            prisma/schema.prisma # <-- FIX 2: Added prisma schema as a base dependency

      - name: Set base_build flag
        id: set-base-flag
        run: |
          if [ "${{ steps.check-base.outputs.any_changed }}" == 'true' ]; then
            echo "build_base=true" >> $GITHUB_OUTPUT
          else
            echo "build_base=false" >> $GITHUB_OUTPUT
          fi

      - name: List all apps from 'apps' directory
        id: list-apps
        run: |
          # FIX 3: Dynamically list all apps instead of using a hardcoded variable
          ALL_APPS_LIST=$(ls -d apps/* | xargs -n 1 basename)
          echo "Found apps: $ALL_APPS_LIST"
          echo "all_apps_list=$ALL_APPS_LIST" >> $GITHUB_OUTPUT
          
      - name: Get affected apps
        id: get-affected
        run: |
          # If base files changed, all apps are affected
          if [ "${{ steps.set-base-flag.outputs.build_base }}" == 'true' ]; then
            echo "Base files changed. All apps will be rebuilt."
            AFFECTED_LIST="${{ steps.list-apps.outputs.all_apps_list }}"
          else
            # Get list of affected apps from Nx, comparing HEAD to the commit before it
            AFFECTED_LIST=$(npx nx affected --base=HEAD~1 --head=HEAD --target=build --plain --select=tasks.target.project)
          fi
          
          echo "Affected apps list: $AFFECTED_LIST"
          
          # Convert space-separated list to a JSON array for the matrix
          JSON_ARRAY=$(echo "$AFFECTED_LIST" | jq -Rsc 'split(" ") - [""]')
          
          echo "affected_apps_list=$AFFECTED_LIST" >> $GITHUB_OUTPUT
          echo "affected_apps_json=$JSON_ARRAY" >> $GITHUB_OUTPUT
          echo "build_base=${{ steps.set-base-flag.outputs.build_base }}" >> $GITHUB_OUTPUT

  # Job 2: Build the base image (ONLY if base files changed)
  build-base:
    name: Build and Push Base Image
    runs-on: ubuntu-latest
    needs: [determine-affected]
    if: needs.determine-affected.outputs.build_base == 'true'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
            
      - name: Build and push eshop-base
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.base
          push: true
          no-cache: true # As you requested
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/eshop-base:latest
          secrets: |
            GIT_AUTH_TOKEN=${{ secrets.GHCR_PAT }}

  # Job 3: Build and push images for ONLY the affected apps
  build-and-push-affected:
    name: Build & Push (${{ matrix.app }})
    runs-on: ubuntu-latest
    needs: [determine-affected, build-base]
    if: needs.determine-affected.outputs.affected_apps_list != ''
    permissions:
      contents: read
      packages: write
    
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.determine-affected.outputs.affected_apps_json) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host

      # --- Build Frontend: user-ui ---
      - name: Build and push user-ui
        if: matrix.app == 'user-ui'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          build-args: |
            APP_NAME=user-ui
            NEXT_PUBLIC_SERVER_URI=${{ vars.NEXT_PUBLIC_SERVER_URI }}
            NEXT_PUBLIC_CHATTING_WEBSOCKET_URI=${{ vars.NEXT_PUBLIC_CHATTING_WEBSOCKET_URI }}
            NEXT_PUBLIC_STRIPE_PUBLIC_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLIC_KEY }}
            NEXT_PUBLIC_USER_URI=${{ vars.NEXT_PUBLIC_USER_URI }}
            NEXT_PUBLIC_SELLER_URI=${{ vars.NEXT_PUBLIC_SELLER_URI }}
          push: true
          no-cache: true # As you requested
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/eshop-user-ui:latest
          secrets: |
            GIT_AUTH_TOKEN=${{ secrets.GHCR_PAT }}

      # --- Build Frontend: seller-ui ---
      - name: Build and push seller-ui
        if: matrix.app == 'seller-ui'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          build-args: |
            APP_NAME=seller-ui
            NEXT_PUBLIC_SERVER_URI=${{ vars.NEXT_PUBLIC_SERVER_URI }}
            NEXT_PUBLIC_CHATTING_WEBSOCKET_URI=${{ vars.NEXT_PUBLIC_CHATTING_WEBSOCKET_URI }}
            NEXT_PUBLIC_STRIPE_PUBLIC_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLIC_KEY }}
            NEXT_PUBLIC_USER_URI=${{ vars.NEXT_PUBLIC_USER_URI }}
            NEXT_PUBLIC_SELLER_URI=${{ vars.NEXT_PUBLIC_SELLER_URI }}
          push: true
          no-cache: true # As you requested
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/eshop-seller-ui:latest
          secrets: |
            GIT_AUTH_TOKEN=${{ secrets.GHCR_PAT }}

      # --- Build Backend Services ---
      - name: Build and push backend (${{ matrix.app }})
        if: matrix.app != 'user-ui' && matrix.app != 'seller-ui'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.backend
          build-args: |
            APP_NAME=${{ matrix.app }}
          push: true
          no-cache: true # As you requested
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/eshop-${{ matrix.app }}:latest
          secrets: |
            GIT_AUTH_TOKEN=${{ secrets.GHCR_PAT }}

  # Job 4: Deploy ONLY the affected services to the VM
  deploy-affected:
    name: Deploy Affected to VM
    needs: [determine-affected, build-and-push-affected]
    if: needs.determine-affected.outputs.affected_apps_list != ''
    runs-on: ubuntu-latest

    steps:
      - name: Deploy to VM via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          script: |
            cd ~/Eshop
            echo ${{ secrets.GHCR_PAT }} | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            git pull
            echo "Creating production .env file from GitHub Secrets..."
            echo "${{ secrets.PROD_ENV_FILE }}" > .env
            
            # Get the space-separated list of affected apps from the first job
            AFFECTED_SERVICES="${{ needs.determine-affected.outputs.affected_apps_list }}"

            echo "Pulling new images for: $AFFECTED_SERVICES"
            docker compose pull $AFFECTED_SERVICES
            
            echo "Restarting services: $AFFECTED_SERVICES"
            docker compose up -d $AFFECTED_SERVICES
            
            echo "Pruning old images"
            docker image prune -f